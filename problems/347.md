347 Top K Frequent Elements
=======================
[Problem description](https://leetcode.com/problems/top-k-frequent-elements/)

#### Difficulty
<span style="color:#FABC60">Medium</span>

#### Keywords
- [Heap](../categories/heap.md)
- [Quicksort](../categories/quicksort.md)
  
#### Idea


#### Complexity
- Runtime: O(Nlogk)
- Space: O(N)
  
#### LC performance
- Runtime: 44 ms
- Memory usage: 16.1 MB

#### Code
##### Heap
```python
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        from heapq import heappush, heappop
        from collections import Counter
        
        heap = []
        for n, v in Counter(nums).items():
            heappush(heap, (-v, n))
        return [heappop(heap)[1] for _ in range(k)]
```

##### Quickselect
```python
import random 


from collections import Counter
from heapq import heappush, heappop


class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        nums = list(Counter(nums).items())
        
        def quickselect(lo, hi):
            if lo >= hi:
                return
            pi = random.randint(lo, hi)
            nums[lo], nums[pi] = nums[pi], nums[lo]
            i, j = lo + 1, hi
            while i <= j:
                while i <= j and nums[i][1] <= nums[lo][1]:
                    i += 1
                while i <= j and nums[j][1] >= nums[lo][1]:
                    j -= 1
                if i < j:
                    nums[i], nums[j] = nums[j], nums[i]
            nums[lo], nums[j] = nums[j], nums[lo]
            n_right = len(nums) - j
            if n_right == k:
                return
            if n_right < k:
                quickselect(lo, j - 1)
            else:
                quickselect(j + 1, hi)
        
        quickselect(0, len(nums) - 1)
        return [n for n, _ in nums[-k:]]
```