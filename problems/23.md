23 Merge k Sorted Lists  
=======================
[Problem description](https://leetcode.com/problems/merge-k-sorted-lists/)

#### Difficulty
<span style="color:red">Hard</span>

#### Keywords
- [Heap](../categories/heap.md)
- [Linked list](../categories/linked_list.md)
- [Merge sort](../categories/mergesort.md)
- [K-way](../categories/k-way.md)
  
#### Idea
   

#### Complexity
- Runtime: O(Nlogk)
- Space: O(k)
  
#### LC performance
- Runtime: 64 ms
- Memory usage: 16.6 MB

#### Code

##### Merge in order
```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def mergeKLists(self, lists: List[ListNode]) -> ListNode:
        dummy = ListNode(0)
        
        for l in lists:
            h = dummy
            p, q = dummy.next, l
            while p and q:
                if p.val < q.val:
                    h.next = p
                    p = p.next
                else:
                    h.next = q
                    q = q.next
                h = h.next
            if p:
                h.next = p
            if q:
                h.next = q
        
        return dummy.next
```

##### Optimization with heap
```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

import heapq

class Solution:
    def mergeKLists(self, lists: List[ListNode]) -> ListNode:
        # use a dummy node to fix the head of the final merge list
        dummy = h = ListNode(0)
        # use a heap to maintain the order of the currently visited nodes by 
        # their values
        heap = []
        
        # add the head of the given lists to the heap together with their 
        # positions
        for i, l in enumerate(lists):
            if not l:
                continue
            heapq.heappush(heap, (l.val, i))
        
        while heap:
            # take from the top of the heap, which is the smallest value in the
            # heap
            v, idx = heapq.heappop(heap)
            # get the corresponding node
            n = lists[idx]
            # add the node to the merge list
            h.next = n
            # move forward the tail of the merge list
            h = h.next
            if n.next:
                # if the current node is not a tail, add its next node to the 
                # heap and update the head of the list
                n = n.next
                heapq.heappush(heap, (n.val, idx))
                lists[idx] = n
        
        return dummy.next
```