173 Binary Search Tree Iterator
=======================
[Problem description](https://leetcode.com/problems/binary-search-tree-iterator/)

#### Difficulty
<span style="color:#FABC60">Medium</span>

#### Keywords
- [Tree in-order traversal](../categories/tree_inorder.md)
- [Stack](../categories/stack.md)
- [Binary search tree](../categories/bst.md)

#### Idea


#### Complexity
- Runtime: O($\alpha(1)$)
- Space O(logN)

#### LC performance
- Runtime: 92 ms
- Memory usage: 19.9 MB

#### Code

##### Python
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
class BSTIterator:
    """
    The BSTIterator is basically an iterative in-order traverser of the BST. 
    Recall the in-order traversal of a binary tree, a stack is used to keep 
    track of tree nodes along the path, and the top of the stack is popped out 
    when the left subtree has been traversed. The idea here is exactly same. 
    """

    def __init__(self, root: TreeNode):
        # stack to track tree nodes along a path
        self.__stack = []
        # the traversal starts from the leftmost leaf
        p = root
        while p:
            self.__stack.append(p)
            p = p.left

    def next(self) -> int:
        """
        The next element is always the top of the stack if not empty

        @return the next smallest number
        """
        stack = self.__stack
        # pop the top of the stack, which is the next element
        n = stack.pop()
        # check the right subtree, if it has a left subtree, we go to the 
        # leftmost leaf and put the nodes along the path into the stack.
        p = n.right
        while p:
            stack.append(p)
            p = p.left
        return n.val

    def hasNext(self) -> bool:
        """
        There are more elements iif there are nodes in the stack waiting to be
        traversed. 

        @return whether we have a next smallest number
        """
        return len(self.__stack) > 0

        
        


# Your BSTIterator object will be instantiated and called as such:
# obj = BSTIterator(root)
# param_1 = obj.next()
# param_2 = obj.hasNext()
```

##### Go
```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */

type BSTIterator struct {
    stack []*TreeNode
}


func Constructor(root *TreeNode) BSTIterator {
    iter := BSTIterator{}
    for root != nil {
        iter.stack = append(iter.stack, root)
        root = root.Left
    }
    return iter
}


/** @return the next smallest number */
func (this *BSTIterator) Next() int {
    next := this.stack[len(this.stack)-1]
    this.stack = this.stack[:len(this.stack)-1]
    p := next.Right
    for p != nil {
        this.stack= append(this.stack, p)
        p = p.Left
    }
    return next.Val
}


/** @return whether we have a next smallest number */
func (this *BSTIterator) HasNext() bool {
    return len(this.stack) > 0
}


/**
 * Your BSTIterator object will be instantiated and called as such:
 * obj := Constructor(root);
 * param_1 := obj.Next();
 * param_2 := obj.HasNext();
 */
```