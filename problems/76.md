76 Minimum Window Substring    
=======================
[Problem description](https://leetcode.com/problems/minimum-window-substring/)

#### Difficulty
<span style="color:red">Hard</span>

#### Keywords
- [Sliding window](../categories/sliding_window.md)
  
#### Idea
 

#### Complexity
- Runtime: O(N)
- Space: O(N)
  
#### LC performance
- Runtime: 132 ms
- Memory usage: 14.4 MB

#### Code
```python
from collections import Counter, defaultdict

class Solution:
    def minWindow(self, s: str, t: str) -> str:
        if not s or not t:
            return ''
        
        # counter of the characters appear in `t`
        counter = Counter(t)
        # track the occurrences of characters of interest in `s`
        occurs = defaultdict(int)
        # assume `s` has all the characters appear in `t`, for now, without any
        # knowledge, the whole string of `s` is the minimum window
        start, end = 0, len(s)
        # counter of valid characters of interest in `s` - a character is valid 
        # only if its occurrences in `s` and `t` match.
        included = 0
        
        # left and right pointers of a sliding window
        l = r = 0
        while r < len(s):
            # if the character at the right pointer is of interest
            if s[r] in counter:
                # increment its occurrence in `s` by 1
                occurs[s[r]] += 1
                # if its occurrences in `s` and `t` match, increment the number 
                # of valid characters by 1
                if occurs[s[r]] == counter[s[r]]:
                    included += 1

            # if all the characters of interest are found, start moving the left 
            # pointer of the window, trying to shrink the window size to find 
            # the minimum 
            while included == len(counter) and l <= r:
                # attempt to reduce the current minimum
                if r - l + 1 <= end - start:
                    start, end = l, r
                # as the left pointer moves forward, characters on the left are 
                # being kicked out from the window. Eventually, not all of 
                # the characters of interest are in the window, and the left 
                # pointer then stops moving forward
                if s[l] in occurs:
                    occurs[s[l]] -= 1
                    if occurs[s[l]] < counter[s[l]]:
                        included -= 1
                l += 1
            
            # move forward the right pointer
            r += 1
        
        # if the start and end have ever been updated, the end must be a valid 
        # index in `s` instead of the intial value. If the end has never been 
        # updated, that means the characters in `t` have never been all found 
        # once in `s`, so the minimun window is nonexistent. 
        return '' if end == len(s) else s[start: end + 1]
            
            
        
        
```